import sys
# fast path if first arg is not an option - or --
# we just exec the script as is using open and read
if len(sys.argv) > 1 and not sys.argv[1].startswith("-"):
    try:
        exec(open(sys.argv[1]).read())
    except SystemExit as e:
        raise SystemExit(e.code)
    # traceback prints are handled natively by pypy
    else:
        raise SystemExit(0)

# only now import heavy stuff
import subprocess, os, re, shutil, argparse
PYPY_PATH, VERSION = os.path.realpath(sys.executable), sys.version

parser = argparse.ArgumentParser(description="PY2STRAP")
parser.add_argument("script", nargs="?", help="path to script to run")
parser.add_argument("-v", "--version", action="store_true", help="show PyPy version")
########################### ^^ argparse strips the '--' and so we can define args.version
# no long form bellow 
parser.add_argument("-i", nargs="+", metavar="PKG", help="install pypy pip packages")
parser.add_argument("-f", metavar="FILE", help="install from requirements file format")
parser.add_argument("-u", nargs="+", metavar="PKG", help="uninstall pypy pip packages")
parser.add_argument("-r", action="store_true", help="nuke current pypy installation")

class GenError(RuntimeError):
    """Generic error wrapper"""

def confirm(action):
    if input(f"{action}? [y/N] ").lower() != "y":
        raise SystemExit(0)

class P2PM:
    def __init__(self, path, version_file="version"):
        self.path = path
        self.version_file = version_file
        self.report_dir = os.path.join(open(version_file).read().strip(), ".p2strap")

    def call(self, *args):
        rc = subprocess.call([self.path] + list(args))
        if rc != 0:
            raise GenError(f"command failed with exit code {rc}")
        return rc

    def pip(self, *args):
        return self.call("-m", "pip", *args)

    def create_store(self):
        os.makedirs(self.report_dir, exist_ok=True)

    def report_path(self, pkg):
        return os.path.join(self.report_dir, f"{pkg}.json")

    def read_report_names(self, pkg):
        path = self.report_path(pkg)
        if not os.path.exists(path):
            return []
        with open(path) as f:
            return re.findall(r'"name":\s*"([^"]+)"', f.read())

    def read_requirements(self, path):
        return [l.split("#")[0].strip() for l in open(path) if l.strip() and not l.startswith("#")]

    def install(self, pkgs):
        self.create_store()
        for pkg in pkgs:
            self.call("-m", "pip", "install", "--no-warn-script-location", "--report", self.report_path(pkg), pkg)

    def uninstall(self, pkgs):
        all_pkgs = []
        for pkg in pkgs:
            names = self.read_report_names(pkg)
            if names:
                all_pkgs.extend(names)
                os.remove(self.report_path(pkg))
            else:
                all_pkgs.append(pkg)
        if all_pkgs:
            self.pip("uninstall", "-y", *all_pkgs)

    def nuke(self):
        pypy_dir = self.report_dir.split("/")[0]
        confirm(f"nuke {pypy_dir}")
        shutil.rmtree(pypy_dir)
        if os.path.exists(self.version_file):
            os.remove(self.version_file)

parser.error = lambda msg: (_ for _ in ()).throw(GenError(msg))

def main():
    try:
        args = parser.parse_args()
        if args.version:
            print(PYPY_PATH)
            print(VERSION)
            raise SystemExit(0)
        pypy_pm = P2PM(PYPY_PATH)
        if args.r:
            pypy_pm.nuke()
        elif args.f:
            pypy_pm.install(pypy_pm.read_requirements(args.f))
        elif args.i:
            pypy_pm.install(args.i)
        elif args.u:
            pypy_pm.uninstall(args.u)
        else:
            raise GenError("no script or action specified")
    except GenError as e:
        print(f"error: {e}\n")
        parser.print_help()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise SystemExit(130)
