import sys, os
PYPY_PATH, VERSION = os.path.realpath(sys.executable), sys.version

# fast path if first arg is not an option - or --
# we just exec the script as is using open and read
if len(sys.argv) > 1 and not sys.argv[1].startswith("-"):
    try:
        exec(open(sys.argv[1]).read())
    except SystemExit as e:
        raise SystemExit(e.code)
    # traceback prints are handled natively by pypy
    else:
        raise SystemExit(0)

# only now import heavy stuff
import subprocess, json, argparse
parser = argparse.ArgumentParser(description="PY2STRAP")
parser.add_argument("script", nargs="?", help="path to script to run")
parser.add_argument("-v", "--version", action="store_true", help="show PyPy version")
########################### ^^ argparse strips the '--' and so we can define args.version
# no long form bellow 
parser.add_argument("-i", nargs="+", metavar="PKG", help="install pypy pip packages")
parser.add_argument("-u", nargs="+", metavar="PKG", help="uninstall pypy pip packages")

class GenericError(Exception):
    pass

class P2PM:
    def __init__(self, path):
        self.path = path
        self.report_dir = os.path.realpath(os.path.join(os.path.dirname(path), "..", ".p2strap"))

    def call(self, *args):
        rc = subprocess.call([self.path] + list(args))
        if rc != 0:
            raise GenericError(f"command failed with exit code {rc}")
        return rc

    def call_output(self, *args):
        return subprocess.check_output([self.path] + list(args), text=True, stderr=subprocess.DEVNULL)

    def pip(self, *args):
        return self.call("-m", "pip", *args)

    def create_store(self):
        os.makedirs(self.report_dir, exist_ok=True)

    def report_path(self, pkg):
        return os.path.join(self.report_dir, f"{pkg}.json")

    def read_report(self, pkg):
        path = self.report_path(pkg)
        if not os.path.exists(path):
            return None
        with open(path) as f:
            return json.load(f)

    def pip_deps(self, pkg):
        try:
            out = self.call_output("-m", "pip", "show", pkg)
            for line in out.splitlines():
                if line.startswith("Requires:"):
                    return [d.strip() for d in line.split(":", 1)[1].split(",") if d.strip()]
        except (subprocess.CalledProcessError, GenericError):
            pass
        return []

    def install(self, pkgs):
        for pkg in pkgs:
            self.call("-m", "pip", "install", "--no-warn-script-location", pkg)

    def delete_report(self, pkg):
        os.remove(self.report_path(pkg))

    def uninstall(self, pkgs):
        all_pkgs = list(pkgs)
        for pkg in pkgs:
            all_pkgs.extend(self.pip_deps(pkg))
        if all_pkgs:
            self.pip("uninstall", "-y", *all_pkgs)

pypy_pm = P2PM(PYPY_PATH)

parser.error = lambda msg: (_ for _ in ()).throw(GenericError(msg))

def main():
    try:
        args = parser.parse_args()
        if args.version:
            print(PYPY_PATH)
            print(VERSION)
            raise SystemExit(0)
        if args.i:
            pypy_pm.install(args.i)
        elif args.u:
            pypy_pm.uninstall(args.u)
        else:
            raise GenericError("no script or action specified")
    except GenericError as e:
        print(f"error: {e}\n")
        parser.print_help()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise SystemExit(130)
